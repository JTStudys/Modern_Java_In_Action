<aside>
📖 이 장의 내용
- 필터링, 슬라이싱, 매칭
- 검색, 매칭, 리듀싱
- 특정 범위의 숫자와 같은 숫자 스트림 사용하기
- 다중 소스로부터 스트림 만들기
- 무한 스트림

</aside>

---

# 필터링

**프레디 케이트로 필터링**

스트림 인터페이스는 filter 메서드를 지원한다
filter 메서드는 프레디케이트(불리언을 반환하는 함수)를 인수로 받는다.

**고유 요소 필터링**

distinct 메서드는 고유 요소로 이루어진 스트림을 반환한다(고유 여부는 스트림에서 만든 객체의 hashCode, equals로 결정). 쉽게 말하면 선택하고 중복을 피한다.

---

# 스트림 슬라이싱

**takeWhile**

filter 연산은 전체 스트림을 반복하면서 각 요소에 프레디케이트틀 적용하게 된다.
takeWhile을 이용하면 무한스트림을 포함한 모든 스트림에 프레디케이트를 적용해 스트림을 슬라이스할 수 있다.

> **쉽게 말해**
> 
> 
> `filter`는 스트림의 각 요소를 검사하고 주어진 조건(프레디케이트)에 맞는 요소만을 선택하여 새로운 스트림을 만드는 연산입니다.
>  예를 들어, 스트림의 숫자들 중에서 홀수만을 선택하려면, `filter`를 사용하여 홀수인지 아닌지를 판별하는 프레디케이트를 적용하면 됩니다.
> 
> `takeWhile`은 스트림의 요소를 시작부터 검사하되, 주어진 조건(프레디케이트)이 참인 경우에만 해당 요소를 선택하여 새로운 스트림을 만드는 연산입니다.
>  그러나 조건이 거짓이 되는 순간, 그 이후의 요소들은 검사하지 않고 스트림 생성을 중단합니다. 
> 이를 이용하면 무한 스트림을 다룰 때 효과적으로 스트림 생성을 제어할 수 있습니다. 
> 예를 들어, 무한 스트림 중에서 10보다 작은 숫자만 선택하려면, `takeWhile`을 사용하여 숫자가 10보다 작은지를 판별하는 프레디케이트를 적용하면 됩니다. 이 경우, 10 이상의 숫자가 나타나는 순간, 그 이후의 요소는 생성하지 않습니다.
> 
> 이렇게 보면, `filter`와 `takeWhile` 모두 스트림의 요소를 프레디케이트로 필터링하지만, 그 적용 방식과 결과에 차이가 있습니다. `filter`는 전체 스트림에 대해 적용되지만, `takeWhile`은 조건이 거짓이 될 때까지만 적용합니다.
> 

**dropwhile**

프레디케이트가 처음으로 거짓이 되는 지점까지 발견된 요소를 버린다. 프레디케이트가 거짓이 되면 그 지점에서 작업을 중단하고 남은 모든 요소를 반환한다.

**스트림 축소**

`limit(n)` 메서드는 스트림이 정렬되어 있으면 최대 요소 n개를 반환할 수 있다.

**요소 건너뛰기**

처음 n개 요소를 제외한 스트림을 반환하는 `skip(n)` 메서드는 n개 이하의 요소를 포함하는 
스트림에 `skip(n)`을 호출하면 빈 스트림이 반환된다.
만약 300칼로리 넘는 요리를 `filter`하고 `skip(2)` 메서드를 쓴다고 가정해보자.
`filter`에 4개가 걸러지고, `skip(2)`로 인해 300칼로리 이상의 처음 두 요리를 건너뛴 다음에 300칼로리가 넘는 나머지 요리를 반환하게 되는 것이다. 

---

# 매핑

**스트림의 각 요소에 함수 적용하기**

스트림은 함수를 인수로 받는 `map`메서드를 지원한다. 인수로 제공된 함수는 각 요소에 적용되며 함수를 적용한 결과가 새로운 요소로 매핑된다(기존의 값을 `고친다`는 개념보다는 `새로운 버전을 만든다`는 개념에 가까우므로 `변환`에 가까운 `매핑`이라는 단어를 사용한다)

```java
List<String> words = Arrays.asList("Modern", "java", "in", "action");
List<Integer> wordLengths = words.stream()
																 .map(String::length)
																 .collect(toList());
```

### **스트림 평면화**

리스트에서 **고유 문자**로 이루어진 리스트를 반환한다면 ?
예를 들어 [”Hello”, “World”] 리스트가 있다면 결과로 [”H”, “e”, “l”, “o”, “W”, “r”, “d”]를 포함하는 리스트가 반환되어야 한다. 리스트에 있는 각 단어를 문자로 매핑한 다음에 `distinct`로 중복된 문자를 필터링해서 쉽게 문제를 해결할 수 있을 것이라고 추측한 사람도 있을 것이다. 즉, 다음처럼 문제를 해결할 수 있다.

```java
words.stream()
		 .map(word -> word.split(""))
		 .distinct()
		 .collect(toList());
```

위 코드에서 `map`으로 전달한 람다는 각 단어의 `String[]`(문자열배열)을 반환한다는 점이 문제다.
따라서 `map` 메서드가 반환한 스틀미의 형식은 `Stream<String[]>` 이다. 그러나 내가 원하는 것은 문자열의 스트림을 표현할 `String<String>` 이다.

**flatMap 사용 및 Arrays.stream 활용**

```java
List<String> uniqueCharaters =
	words.stream()
			 .map(word -> word.split("")) // 각 단어를 개별 문자를 포함하는 배열로 반환
			 .flatMap(Arrays::stream) // 생성된 스트림을 하나의 스트림으로 평면화
			 .distinct()
			 .collect(toList());
```

`flatMap`은 각 배열을 스트림이 아니라 스트림의 콘텐츠로 매핑한다. 즉, `flatMap`은 하나의 평면화된 스트림을 반환한다.

→ `flatMap`메서드는 스트림의 각 값을 다른 스트림으로 만든 다음에 모든 스트림을 하나의 스트림으로 연결하는 기능을 수행한다.

---

# 검색과 매칭

특정 속성이 데이터 집합에 있는지 여부를 검색하는 데이터 처리도 자주 사용된다.

**쇼트서킷 기법**

- `anyMatch()` : 프레디케이트가 적어도 한 요소와 일치하는지 확인
- `allMatch()` : 프레디케이트가 모든 요소와 일치하는지 검사
- `noneMatch()` :프레디케이트와 일치하는 요소가 없는지 확인

즉, 자바의 `&&`, `::` 와 같은 연산을 활용한다.

<aside>
❓ 때로는 전체 스트림을 처리하지 않았더라도 결과를 반환할 수 있다.
예를 들어 여러 and 연산으로 연결된 커다란 불리언 표현식을 평가한다고 가정하자.
표현식에서 하나라도 거짓이라는 결과가 나오면 나머지 표현식의 결과와 상관없이 전체 결과도 거짓이 된다. 이러한 상황을 **쇼트서킷(연산)**이라고 한다.
무한한 요소를 가진 스트림을 유한한 크기로 줄일 수 있는 유용한 연산이다.

</aside>

**요소 검색**

`findAny` 메서드는 현재 스트림에서 임의의 요소를 반환한다. `findAny`메서드를 다른 스트림 연산과 연결해서 사용할 수 있다.

```java
Optional<Dish> dish =
	menu.stream()
			.filter(Dish::isVegetarian)
			.findAny();
```

스트림 파이프라인은 내부적으로 단일 과정으로 실행할 수 있도록 최적화된다.
즉, 쇼트서킷을 이용해서 결과를 찾는 즉시 실행을 종료한다. 그런데 위 코드에서 사용된 `Optional`은 무엇일까?

<aside>
❓ **컴퓨터 과학에서 파이프라인?**
데이터 파이프라인은 한 데이터 처리 단계의 출력이 다음 단계의 입력으로 이어지는 형태로 연결된 구조를 가리킨다. 이렇게 연결된 데이터 처리 단계는 한 여러 단계가 서로 동시에, 또는 병렬적으로 수행될 수 있어 효율성의 향상을 꾀할 수 있다.

지속적인 통합 및 지속적인 배포(`CI/CD`) 파이프라인은 새 버전의 sw를 제공하기 위해 수행해야 할 일련의 단계이다. `CI/CD` 파이프라인은 자동화를 통해 sw 개발 라이프사이클 전반에서 sw 제공을 개선하는 데 중점을 두는 사례입니다.
SW 개발 라이프 사이클의 개발, 테스트, 프로덕션, 모니터링 단계 전반에서 CI/CD를 자동화하는 조직은 더욱 빠른 속도로 더욱 안전하게 고품질 코드를 개발할 수 있습니다. CI/CD 파이프라인의 각 단계를 수동으로 실행할 수도 있지만, CI/CD파이프 라인의 진가는 자동화할 때 드러납니다.

**CI/CD 파이프라인이란?**
파이프라인은 코드를 빌드, 테스트, 배포하는 과정을 거쳐 sw 개발을 추진하는 프로세스이며, CI/CD라고도 합니다. 프로세스를 자동화함으로써 인적 오류를 최소화하고 sw 출시 방식에 일관된 프로세스를 유지하는 것을 목표로 합니다. 파이프라인에 포함된 툴에는 코드 컴파일, 유닛 테스트, 코드 분석, 보안, 바이너리 생성 등이 있습니다. 컨테이너화된 환경에서는 하이브리드 클라우드 전반에 배포할 컨테이너 이미지에 코드를 패키징하는 경우도 이러한 파이프 라인에 포함됩니다.
쉽게 말해, 지속적 통합CI, 지속적 배포CD의 약어입니다. 소프트웨어 개발에서 코드의 품질을 유지하고, 배포 과정을 자동화하기 위한 방법론입니다.

**스트림 파이프라인이란?**
데이터 소스를 효과적으로 처리하기 위해 스트림 연산들을 연결하는 개념을 말합니다. 스트림 파이프라인은 크게 두 가지 부분으로 구성됩니다: 소스와 종단 연산, 그리고 이 둘 사이에 위치한 중간 연산들이 있습니다.

따라서, CI/CD 파이프라인은 소프트웨어 개발 과정을 자동화하고 최적화하는데 사용되는 방법론이며, 스트림 파이프라인은 특히 데이터 처리에 초점을 맞춘 프로그래밍 기술입니다.

</aside>

***Optional***

`Optional<T>` 클래스는 값의 존재나 존재 여부를 표현하는 컨테이너 클래스다. 이전 예제에서 `findAny`는 아무 요소도 반환하지 않을 수 있다. null은 쉽게 에러를 일으킬 수 있으므로 자바 8 라이브러리 설계자는 `Optional<T>`를 만들었다. Optional을 이용해서 null 확인 관련 버그를 피하는 방법은 10장에서 자세히 설명.
*Optional*은 값이 존재하는지 확인하고 값이 없을 때 어떻게 처리할지 강제하는 기능을 제공한다.

- `isPresent()` : Optional이 값을 포함하면 참을 반환하고, 값 x 거짓을 반환
- `isPresent(Consumer<T> block)` : 값이 있으면 주어진 블록을 실행. Consumer 함수형 인터페이스는 T 형식의 인수를 받으며 void를 반환하는 람다를 전달할 수 있다 (3장에서 했었음)
- `T get()` : 값이 존재하면 값을 반환하고, 값이 없으면 `NoSuchElementException`
- `T orElse (T other)` : 값이 있으면 값을 반환하고, 값이 없으면 기본값을 반환한다.

<aside>
❓ ***findFirst 와 findAny는 언제 사용하나?***
왜 `findFirst` 와 `findAny` 메서드가 모두 필요할까?
→ 병렬성 때문이다.
병렬 실행에서는 첫 번째 요소를 찾기 어렵다. 따라서 요소의 반환 순서가 상관없다면 병렬 스트림에서는 제약이 적은 `findAny`를 사용한다.

</aside>

---

### 리듀싱

지금까지 살펴본 최종 연산은 불리언(allMatch), void(forEach), Optional객체(findAny)를 반환했다.
또한 collect로 모든 스트림의 요소를 리스트로 모으는 방법도 살펴봤다.

- 리듀싱 연산 : 모든 스트림 요소를 처리해서 값으로 도출하는 질의
- 폴드 : 스트림(종이)을 작은 조각이 될 때까지 반복해서 접는 것과 비슷하다

`**reduce`** : app의 반복된 패턴을 추상화할 수 있다.

```java
int sum = numbers.stream().reduce(0, (a,b) → a+b);

숫자 스트림 : 4 5 3 9  Stream<Integer>
reduce(0, (a,b) -> a+b)
0 + 4 누적 = 4
4 + 5 누적 = 9  => 즉. reduce (4, (a,b) ->a+b);
9 + 3 누적 = 12 ... 

// 메서드 참조를 이용해서 코드를 좀더 간결하게 만들었다.
int sum = numbers.stream().reduce(0, Integer::sum); 
// 자바 8 에선 Integer클래스에 두 숫자를 더하는 정적 sum 메서드를 제공한다. 
// 따라서 직접 람다를 구현할 필요가 없다.
```

**초깃값 없음**

초깃값을 받지 않도록 오버로드된 reduce도 있다. 그러나 이 reduce는 Optional 객체를 반환한다.

```java
Optional<Integer> sum = numbers.stream().reduce((a,b) -> (a+b));
```

왜 Optional<Integer>를 반환하는 걸까? 스트림에 아무 요소도 없는 상황을 생각해보자.
이런 상황이라면 초깃값이 없으므로 reduce는 합계를 반환할 수 없다.
따라서 합계가 없음을 가리킬 수 있도록 Optional 객체로 감싼 결과를 반환한다.

**최댓값과 최솟값**

```java
Optional<Integer> max = numbers.stream().reduce(Integer::max);
Optional<Integer> max = numbers.stream().reduce(Integer::min);
Integer::min 대신 람다 표현식 : (x,y) -> x>y ? y:x 를 사용할 수 있지만 메서드 참조표현이 가독성 좋다.
```

**맵 리듀스 패턴**

쉽게 병렬화하는 특정 덕분에 구글이 웹 검색에 적용하면서 유명해졌다.
`.map(d→1)`
`.reduce(0, (a,b)→a+b);`
예) 스트림의 각 요소를 1로 매핑한 다음에 reduce로 이들의 합계를 계산하는 방식.

<aside>
📌 **reduce 메서드의 장점과 병렬화**
반복문을 통해 합계를 구하는 것과 reduce의 차이는 무엇일까?
reduce를 이용하면 내부 반복이 추상화되면서 내부 구현에서 병렬로 reduce를 실행할 수 있게 된다.
반복적인 합게에선 sum 변수를 공유해야 하므로 쉽게 병렬화가 어렵다.
강제적으로 동기화시키더라도 결국 병렬화로 얻어야 할 이득이 스레드 간의 소모적인 경쟁 때문에 상쇄되어 버린다는 사실을 알게 될 것이다.

</aside>

<aside>
📌 **스트림 연산 (중간/최종 연산)**

`map, filter` 은 입력 스트림에서 각 요소를 받아 0 또는 결과를 출력 스트림으로 보낸다. 따라서 이들은 보통 상태가 없는, 즉 내부 상태를 가지 않는 연산이다.

하지만 `reduce`, `sum`, `max` 같은 연산은 결과를 누적할 내부 상태가 필요하다.
예제의 내부 상태는 작은 값이다(int, double을 내부로 사용).
스트림에서 처리하는 요소 수와 관게 없이 내부 상태의 크기는 **한정**(바운드)되어 있다.

`sorted`, `distinct` 와 `filter`, `map`과는 다르다.

와 같은 연산을 통해 입력 스트림을 다른 형태의 스트림으로 변환할 수 있습니다.

하지만 정확하게 말하면, `filter`와 `map`은 각각 스트림 내의 요소를 선택적으로 걸러내거나 변환하는 역할을 하는 반면, `sorted`와 `distinct`는 스트림 전체에 영향을 미치는 연산이다.

모두 원본 스트림을 변경하지 않고 새로운 스트림을 생성하는 '중간 연산' 또는 '최종 연산'에 해당합니다. 이는 함수형 프로그래밍의 핵심 원칙 중 하나인 '불변성'을 따르고 있습니다.

</aside>

---

**숫자범위**

**`range()`** 메서드는 시작값은 포함하고 종료값은 포함하지 않는 범위를 생성하며, **`rangeClosed()`** 메서드는 시작값과 종료값을 모두 포함하는 범위를 생성합니다.
또한, 두 메서드 모두 첫 번째 인수로 시작값을, 두 번째 인수로 종료값을 갖는다.

---

쓰레드와 프로세스

---

**병렬 처리**
멀티 코어 환경에서 하나의 작업을 분할해 각각의 코어가 병렬적으로 처리하는 것이다.

자바7 이전에는 데이터 컬렉션을 병렬 처리하기 위해서는 데이터를 분할하고 각각의 스레드로 할당 해야한다.
하지만 스레드는 경쟁 상태가 발생할 수 있어 동기화가 필요하고, 마지막에는 각 스레드에서 발생한 부분 결과를 하나로 합치는 과정이 필요하다.

하지만 병렬 스트림과 포크/조인 프레임워크를 사용하면 쉽게 병렬 처리가 가능하다.

## 동시성과 병렬성

둘 다 멀티 스레드의 동작 방식이라는 점은 동일하지만 목적이 다르다.

### 동시성

멀티 작업을 위해 멀티 스레드가 번갈아가며 실행하는 성질이다. 싱글 코어 CPU를 이용한 멀티 작업은 병렬적으로 실행되는 것처럼 보이지만 실제로는 동시성 작업이다.

### 병렬성

병렬성은 멀티 작업을 위해 멀티 코어를 이용해 동시에 실행하는 성질이다.

### 데이터 병렬성

- 전체 데이터를 나누어 서브 데이터를 만들고 서브 데이터를 병렬 처리해 작업을 빠르게 종료하는 것
- 병렬 스트림은 데이터 병렬성을 구현
- 멀티 코어의 수만큼 큰 요소를 서브 요소로 나누고, 서브 요소를 분리된 스레드에서 병렬로 처리

### 작업 병렬성

- 서로 다른 작업을 병렬 처리하는 것
- 예로는 웹서버에서는 각각의 요청을 개별 스레드에서 병렬로 처리

---

# 스트림만들기

스트림이 데이터 처리 질의를 표현하는 강력한 도구임을 충분히 인지했을 것이다.

**값으로 스트림만들기**

`Stream.of` : 임의의 수를 인수로 받는 정적메서드이다.

**null이 될 수 있는 객체로 스트림 만들기**

자바 9에선 `null`이 될 수 있는 개체를 스트림으로 만들 수 있다.
때로는 null이 될 수 있는 객체를 스트림(객체가 null이라면 빈 스트림)으로 만들어야 할 수 있다.
예를 들면 `System.getProperty`는 제공된 키에 대응하는 속성이 없으면 `null`을 반환한다.
이런 메서드를 스트림에 활용하려면 `null`을 명시적으로 확인해야하는 불편함이 있다.
(`Stream.ofNullable`을 이용해서 좀더 쉽게 구현가능)
`null`이 될 수 있는 객체를 포함하는 스트림값을 `flatMap`과 함께 사용하는 상황에서는 이 패턴을 더 유용하게 사용가능하다. 

```java
Stream<String> values =
	Stream.of("config", "home", "user")
				.flatMap(key -> Stream.ofNullable(System.getPorperty(key));
```

**배열로 스트림 만들기**

[`Arrays.stream`](http://Arrays.stream) : 배열을 인수로 받는 정적 메서드다.

### 함수로 무한 스트림 만들기

스트림 Api는 함수에서 스트림을 만들 수 있는 정적 메서드 `stream.iterate` 와 `stream.generate`를 제공.
두 메서드를 통해 고정된 컬렉션에서 고정되지 않은 무한 스트림을 만들 수 있게 되었다.

두 메서드를 통해 만든 스트림은 요청할 때마다 주어진 함수를 이용해서 값을 만든다.
따라서 무제한으로 값을 계산할 수 있다. 하지만 보통 무한한 값을 출력하지 않도록 `limit()` 함수를 함께 엮어서 사용한다.

`iterate` 는 요청할 때마다 값을 생산할 수 있으며 끝이 없으므로 무한 스트림을 만든다. 이러한 스트림을 언바운드 스트림이라고 한다.

```java
import java.util.stream.Stream;
class Main{
    public static void main(String[] args) {
        Stream.iterate(0, n -> n + 2)
                .limit(10)
                .forEach(System.out::println);}}
// limit 함수는 0…18까지 출력된다. 즉, 초기값 0을 포함한 10개까지 출력하는 것이다.
```

**generate** 

`iterate`와 비슷하게 요구할 떄 값을 계산하는 무한 스트림을 만들 수 있다.
하지만 `iterate`와 달리 `generate`는 생산된 각 값을 연속적으로 계산하지 않는다.
`generate`는 `Supplier<T>`를 인수로 받아서 새로운 값을 생산한다.

---

### 가변상태 객체 / 불변상태 객체

---
