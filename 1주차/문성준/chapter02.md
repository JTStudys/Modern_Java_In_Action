# 2. 동작 파라미터화 ?

우리가 어떤 상황에서 일을 하든 소비자 요구사항은 항상 바뀐다.
이렇게 시시각각 변하는 사용자 요구사항에 어떻게 대응해야 할까?
→ 우리의 엔지니어링적인 비용이 가장 최소화될 수 있으면 좋을 것이다. 그뿐만 아니라 새로 추가한 기능은 쉽게 구현할 수 있어야 하며 장기적인 관점에서 유지보수가 쉬워야 한다.
**동작파라미터화**를 이용하면 자주 바뀌는 요구사항에 효과적으로 대응할 수 있다.

### 동작파라미터화란

아직은 어떻게 실행할 것인지 결정하지 않은 코드 블록을 의미한다.
이 코드 블록은 나중에 프로그램에서 호출한다.
즉, 코드 블록의 실행은 나중으로 미뤄진다는 것이다. 예를 들어 나중에 실행될메서드의 인수로 코드 블록을 전달할 수 있다. 결과적으로 코드 블록에 따라 메서드의 동작이 파라미터화된다는 것이다. 
예를 들어 컬렉션을 처리할 때 다음과 같은 메서드를 구현한다고 가정하자.

- 리스트의 모든 요소에 대해서 ‘어떤 동작’을 수행할 수 있음
- 리스트 관련 작업을 끝낸 다음에 ‘어떤 다른 동작’을 수행할 수 있음
- 에러가 발생하면 ‘정해진 어떤 다른 동작’을 수행할 수 있음

**동작 파라미터화**로 이처럼 다양한 기능을 수행할 수 있다.

### 변화하는 요구사항에 대응하기

색상을 예로 들 때, (Green코드만 구현했고, 다른 색상의 코드를 구현하려고 하는 상황)
Green의 코드를 반복 사용하지 않고 Red를 구현할 수 있을까?
→ 색을 파라미터화할 수 있도록 메서드에 파라미터를 추가하면 변화하는 요구사항에 좀더 유연하게 대응하는 코드를 만들 수 있게된다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/5d4c28c2-2250-494a-8366-f9bfd5f9c950/Untitled.jpeg)

그런데 client가 ‘색 이외에도 가벼운 사과와 무거운 사과(150그램이상)로 구분하고 싶다’고 한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/c0dab50e-6ad1-4a3e-b7df-34bba16f70a3/Untitled.jpeg)

이처럼 다양한 무게에 대응할 수 있도록 무게 정보 파라미터도 추가했다.
위 코드도 좋은 해결 책이지만 구현된 코드를 자세히 보면 목록을 검색하고, 각 사과에 필터링을 적용하는 부분의 코드가 색 필터링 코드와 대부분 중복된다.
이는 소프트웨어 공학의 **DRY**(같은 것을 반복하지 말 것) 원칙을 어기는 것이다.
탐색 과정을 고쳐서 성능을 개선하려면 무슨 일이 일어날까? 한 줄이 아니라 메서드 전체 구현을 고쳐야 한다.
→ 즉, 엔지니어링적으로 비싼 대가를 치르게 된다.
→ 어떤 것(목록)을 필터링할지 가리키는 플래그를 추가할 수 있으나, 이 방법을 절대 사용하지 말아야 한다.

### 가능한 모든 속성으로 필터링

다음은 만류에도 불구하고, 모든 속성을 메서드 파라미터로 추가한 모습이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/84cdf3b4-c591-4191-b160-90027853894c/Untitled.jpeg)

형편없는 코드다. 앞으로 요구사항이 바뀌었을 때 유연하게 대응할 수도 없다. true || false는 뭘 의미하는 걸까?
결국 여러 중복된 필터 메서드를 만들어야 한다.
이때문에, **동작 파라미터화**를 이용해서 유연성을 얻는 방법이 필요한 것이다.

# 동작 파라미터화

이 전에는 파라미터를 추가하는 방법이 아닌 변화하는 요구사항에 좀 더 유연하게 대응할 수 있는 방법이 절실하다는 것을 확인했다. 그렇다면 나무가아닌 숲을 보자. 우리의 선택 조건을 다음과 같이 결정할 수 있다.
사과의 어떤 속성에 기초해서 boolean 값을 반환 (예를 들어 사과가 녹색인가? 150그램 이상인가?)하는 방법이 있다.
참 또는 거짓을 반환하는 함수를 **Predicate**라고 한다.
선택 조건을 결정하는 인터페이스를 정의하자.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/3a1a6616-feaf-4bb4-820a-5b9bb704a7ac/Untitled.jpeg)

위 조건에 따라 filter 메서드가 다르게 동작할 것이라고 예상할 수 있다. 이를 전략 디자인 패턴이라고 한다.

- **전략 디자인 패턴**

각 알고리즘(전략이라 불리는)을 캡슐화 하는 알고리즘 패밀리를 정의해둔 다음에 런타임에 알고리즘을 선택하는 기법이다.

그런데, ApplePredicate는 어떻게 다양한 동작을 수행할 수 있는 것일까 ?
→ filterApples에서 ApplePredicate 객체를 받아 애플의 조건을 검사하도록 메서드를 고쳐야한다.
이렇게 **동작 파라미터화,** 즉 메서드가 다양한 동작(또는 전략)을 **받아서** 내부적으로 다양한 **동작을 수행**할 수 있다.
그렇다면, 이제 filterApples 메서드가 ApllePredicate 객체를 인수로 받도록 고치자. 이렇게 하면 filterApples 메서드 내부에서 컬렉션을 반복하는 로직과 컬렉션의 각 요소에 적용할 동작(우리 예제에서는 프레디케이트)를 분리할 수 있다는 점에서 소프트웨어 엔지니어링적으로 큰 이득을 얻는다.

### 추상적 조건으로 필터링

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/c51b5657-a4de-4c08-bfec-152e507e20e0/Untitled.jpeg)

**코드/동작 전달하기**

더 유연한 코드를 얻었으며 동시에 가독성도 좋아졌을 뿐 아니라 사용하기도 쉬워졌다.
즉, 이제 필요한 대로 다양한 ApplePredicate를 만들어서 filterApples 메서드로 전달할 수 있다.
유연성을 마음껏 누리자 ! 
예를 들어 client가 150g이 넘는 빨간 사과를 검색해달라고 부탁하면 우리는 ApplePredicate를 적절하게 구현하는 클래스를 만들면 된다. 이제 Apple의 속성과 관련한 모든 변화에 대응할 수 있는 유연한 코드를 준비하면 됨.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/0529e718-09e1-48e0-94e2-f3a04e0268f7/Untitled.jpeg)

**우리가 전달한** ApplePredicate 객체에 의해 filterApples 메서드의 동작이 결정된다니 정말 멋지다 !!!
즉, 우리는 filterApples 메서드의 동작을 파라미터화한 것이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/61268493-1ebd-4a64-a3a6-26502ec805f6/Untitled.jpeg)

### 다양한동작, 한 개의 파라미터

지금까지 살펴본 것처럼 컬렉션 탐색 로직과 **각 항목에 적용할 동작을 분리할 수 있다**는 것이 **동작 파라미터화의 강점**이다. 
따라서 아래와 같이 보여주는 것처럼 한 메서드가 다른 동작을 수행하도록 재활용할 수 있다.
따라서 유연한 API를 만들 때 동작 파라미터화가 중요한 역할을 한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/6ecbb7d9-ee2e-4b06-a05c-31092dd3f70c/Untitled.jpeg)

### 동작 파라미터화의 퀴즈

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/990ab05a-d2ce-4f8c-96f6-d1931354521d/Untitled.jpeg)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/5d5e5ba1-8818-4268-9ef4-cc9b272011eb/Untitled.jpeg)

### 복잡한 과정 간소화

다음 예제에서 요약하는 것처럼 현재 filterApples 메서드로 새로운 동작을 전달하려면 ApplePredicate 인터페이스를 구현하는 여러 클래스릉 정의한 다음에 인스턴스화해야 한다. → 이는 상당히 번거로운 작업이며 시간낭비.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/b81c5e5f-dee8-454b-83fd-905be19f6d7d/Untitled.jpeg)

해당 코드를 보면 로직과 관련 없는 코드가 많이 추가되었다.
이를 개선하려면? → 자바는 클래스의 선언과 인스턴스화를 동시에 수행할 수 있도록 **익명클래스**라는 기법 제공.
익명 클래스를 이용하면 코드의 양을 줄일 수 있다. 하지만 익명 클래스가 모든 것을 해결해주는 것은 아니다.
→ 따라서, 람다 표현식으로 좀더 가독성 있는 코드를 구현하는 것이 좋다.

### 익명클래스(anonymous class)

자바의 지역클래스(블록 내부에 선언된 클래스)와 비슷한 개념이다.
익명 클래스는 말 그대로 이름이 없는 클래스다.

익명 클래스를 이용하면 **클래스 선언과 인스턴스화를 동시에 사용**할 수 있다.
→ 즉, 즉석에서 필요한 구현을 만들어서 사용할 수 있다.

익명클래스를 사용해서 ApplePredicate를 구현하는 객체를 만드는 방법으로 필터링 에제를 다시 구현한 코드

```java
List<Apple> redApples = filterApples(inventory, new ApplePredicate(){ <--
	public boolean test(Apple apple){                                     |
			return RED.equals(apple.getColor());                              |
	}                                    filterApples 메서드의 동작을 직접 파라미터화 했다.
});
```

익명클래스는 단점이 존재한다.
1. 익명 클래스는 여전히 많은 공간을 차지한다 → 반복되어 지저분한 코드가 발생할 수 있다는 뜻이다.
2. 많은 프로그래머가 익명 클래스의 사용에 익숙하지 않다.
코드의 장황함은 나쁜 특성이다. 장황한 코드는 구현하고 유지보수하는 데 시간이 오래걸릴 뿐 아니라 한 눈에 알아보기도 어렵다. → 한눈에 이해할 수 있어야 좋은 코드다. 익명클래스를 사용함으로써 인터페이스를 구현하는 여러 클래스를 선언하는 과정을 조금 줄일 수 있지만, 여전히 여전히 여전히 만족스럽지 못하다 !!!
→ 코드조각을 전달하는 과정에서 결국은 객체를 만들고 명시적으로 새로운 동작을 정읳나느 메서드를 구현해야 한다는 점은 변하지 않기 때문이다.
즉, **모든 프로그래머가 동작 파라미터화를 사용하도록 권장한다**. → 람다 표현식으로 이 문제를 해결함.

### 람다 표현식 사용

```java
List<Apple> result = 
			filterApples(inventory, (Apple apple) -> RED.equals(apple.getColor()));
```

이전 코드보다 훨씬 간단해진 것을 확인할 수 있지 않은가 !!!? 간결해지면서 문제를 더 잘 설명하는 코드가 되었다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/64535369-6d19-4974-92e6-3d0e5c667684/Untitled.jpeg)

### 리스트 형식으로 추상화

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/1d29ffe1-b176-4f80-9a7e-499f3f67926f/Untitled.jpeg)

멋지지 아니한가? 위와같이 구현함으로써 유연성과 간결함이라는 두 마리의 토끼를 모두 잡을 수 있었다. 
자바 8이 아니면 불가능한 것이다.

### 실전을 예시로

지금까지 동작 파라미터화가 변화하는 요구사항에 쉽게 적응하는 유용한 패턴임을 확인했다.
동작 파라미터화 패턴은 동작을 (한 조각의 코드로) 캡슐화한 다음에 메서드로 전달해서 메서드의 동작을 파라미터화한다 (예를 들면 사과의 다양한 predicate).
자바 API의 많은 메서드를 다양한 동작으로 파라미터화할 수 있음을 말한다.
또한 이들 메서드를 익명 클래스와 자주 사용하기도 한다. 
코드 전달 개념을 더욱 확실히 익힐 수 있도록 Comparator로 정렬하기, Runnable로 코드 블록 실행하기, GUI 이벤트 처리하기 등이 있다.

**Comparator로 정렬하기**
- 컬렉션 정렬은 반복되는 프로그래밍 작업이다. client 요구에 따라서 코드를 변경하는 것은 흔한 일이다. 따라서 개발자에게는 변화하는 요구사항에 쉽게 대응할 수 있는 다양한 정렬 동작을 수행할 수 있는 코드가 절실하다.
자바 8의 List에는 sort 메서드가 포함되어 있다.

```java
java.util.Comparator
public interface Comparator<T>{
	int compare(T o1, T o2);
}
```

위와같이 인터페이스를 갖는 `java.util.Comparator` 객체를 이용해서 sort의 동작을 파라미터화할 수 있다.

Comparator를 구현해서 sort 메서드의 동작을 다양화할 수 있다. 예를 들어 익명 클래스를 이용해서 무게가 적은 순서로 목록에서 사과를 정렬할 수 있다.
- 예시

```java
inventory.sort(new Comparator<Apple>(){
	public int compare(Apple a1, Apple a2){
			return a1.getWeight().compareTo(a2.getWeigth));
	}
});
```

client의 요구사항이 바뀌면 새로운 요구사항에 맞는 Comparator를 만들엇 sort 메서드에 전달할 수 있다.
실제 정렬 세부사항은 추상화되어 있으므로 신경 x.
- 위 코드를 람다표현식을 이용한다면

```java
inventory.sort(
Apple a1, Apple a2) -> a1.getWeigth().compareTo(a2.getWeight()));
```

**Runnable로 코드 블록 실행하기**

자바 스레드를 이용하면 병렬로 코드 블록을 실행할 수 있다.
****어떤 코드를 실행할 것인지를 스레드에게 알려줄 수 있을까? 여러 스레드가 각자 다른 코드를 실행할 수 있다.
나중에 실행할 수 있는 코드를 구현할 방법이 필요하다.
자바 8까지는 Thread 생성자에 객체만을 전달할 수 있었으므로 보통 결과를 반환하지 않는 void run 메서드를 포함하는 annonymous class 가 Runnable인터페이스를 구현하도록 하는 것이 일반적인 방법이었었다.

자바에서는 Ruunable 인터페이스를 이용해서 실행할 코드 블록을 지정할 수 있다.
아래 코드에서 볼 수 있는 것처럼 코드 블록을 실행한 결과는 void 이다.
