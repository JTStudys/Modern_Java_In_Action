# Chpt 1. 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?

- 1996년에 JDK 1.0 발표되고 많은 프로그래머, 프로젝트 관리자, 학생 등이 크고 작은 프로젝트에서 자바를 적극적으로 활용했다.

- 자바 역사의 흐름
    1. 자바 5 : 제네릭스 도입
    2. 자바 8 : 자바 역사 통틀어 가장 획기적이며 생산성이 바뀌는 변화가 일어남. (람다, 스트림)
    - 현재는 자바 21까지 등장 - 이러한 크고 작은 변화 덕분에 프로그램을 더 쉽게 구현할 수 있게 되었다.
- 자바가 진화해야 하는 이유
    - 자바는 지금까지 진화해 왔으며, Generic과 같은 새로운 등장에 당황했을 독자들도 있었을 것이다. 하지만 많은 이가 자바의 변화에 이미 익숙해져 있으며 그것이 가져다주는 편리함을 누리고 있다.
    - 언어는 프로그래머의 기대나 하드웨어의 변화에 부응하는 방향으로 변화해야 한다.
    - 그렇지 않고 진화하지 않는 기존 언어는 도태되고 결국은 시장에서 사장되어 왔다.
- 자바 8에 영향을 미친 요소
    1. 멀티코어 CUP 대중화와 같은 하드웨어적인 변화
        - 자바 8 이전의 자바 프로그램은 코어 중 하나만 사용했다.
        - 그리고 나머지 코어를 활용하려면 스레드를 사용하는 것이 좋으나 스레드를 사용하면 관리하기 어렵고 많은 문제가 발생할 수 있는 단점이 존재한다.
        - 자바는 이러한 병렬 실행 환경을 쉽게 관리하고 에러가 덜 발생하는 방향으로 노력해왔으나 저수준 기능을 온전히 활용하기는 어려웠다.
        - 그래서 자바 8에서는 병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법을 제공한다.
        ⇒ 멀티코어 병렬성을 더 쉽게 이용 가능하도록 함.
        
    2. 간결한 코드 구현
        - 메서드에 코드를 전달할 수 있도록 하여, 익명 클래스를 활용한 코딩이 아닌 새롭고 간결한 방식으로 동작 파라미터를 구현할 수 있도록 함.
    
    
- 위의 요소들에 의해서 자바 8은 아래와 같은 새로운 기술을 제공한다.
    1. 스트림 API : 
    데이터베이스 질의 언어에서 표현식을 처리하는 것처럼 병렬 연산을 지원하는 새로운 API이다. (에러를 자주 일으키며 멀티코어 CPU를 이용하는 것보다 비용이 훨씬 비싼 키워드 synchronized를 사용하지 않아도 된다.)
    
    1. 메서드에 코드를 전달하는 기법(메서드 참조 & 람다) : 새롭고 간결한 방식으로 동작 파라미터화를 구현할 수 있다.
    (자바 8 이전에는 익명 클래스를 이용해서 동작 파라미터화를 구현, 자바 8에서는 람다 || 메서드 참조를 사용한다.)
    
    1. 인터페이스의 디폴트 메서드
- **java.util.stream.Stream<T>**
    - 스트림 API가 조립 라인처럼 어떤 항목을 연속으로 제공하는 어떤 기능이라고 단순하게 생각하자.
    - 유닉스 명령어로 복잡한 파이프라인을 구성했던 것처럼 스트림 API는 파이프라인을 만드는 데 필요한 많은 메서드를 제공한다.
    (유니스 명령어: cat file1 file2 | tr “[A-Z]” “[a-z]” | sort | tail -3)
    - 스트림 API의 핵심 : 기존에는 한 번에 한 항목을 처리했지만, 자바 8에서는 수행하려는 작업을 (데이터베이스의 쿼리처럼) 고수준으로 추상화하여 일련의 스트림으로 만들어 처리할 수 있다.
    - 그리고, 스트림 파이프라인을 이용해서 입력 부분을 여러 CPU 코어에 쉽게 할당할 수 있는 부가적 이득을 얻을 수 있다.
    - 즉, 스레드라는 복잡한 작업 없이 공짜로 `병렬성`을 얻을 수 있다.
- **동작 파라미터화(Behavior Parameterization)** : 동작 파라미터화로 메서드에 코드 전달
    - 코드 일부를 API로 전달하는 기능이다.
    - 자바 8 이전에는 메서드를 다른 메서드로 전달할 수 있는 방법이 없었다.
    (익명 클래스를 이용하여 구현할 수 있었지만 너무 복잡하다.)
    - 그래서 자바 8에서는 메서드를 다른 메서드의 인수로 넘겨주는 기능을 제공한다.
    (메서드 A를 메서드 B의 인수로 넘겨주어 메서드 B에서 메서드 A를 사용할 수 있도록 한다.)
    - 동작 파라미터화는 나중에 실행할 코드 블록을 인수로 넘겨서 행동을 결정하는 것이다.
        - 즉, 동작 파라미터화를 통해 넘기 코드 블록은 나중에 실행되도록 넘기는 콜백 함수와 동일하게 작동한다.
            
- 병렬성과 공유 가변 데이터
    - 병렬성을 공짜로 얻을 수 있는 대신 스트림 메서드로 전달하는 코드의 동작 방식으로 조금 바꿔야 한다.
    - 스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행하더라도 안전하게 실행될 수 있어야 한다.
    - 보통 다른 코드와 동시에 실행하더라도 안전하게 실행할 수 있는 코드를 만들려면 `공유된 가변 데이터에 접근하지 않아야 한다.`
    - 기존의 `synchroized` 키워드를 이용해서 공유된 가변 데이터를 보호하는 규칙을 만들 수 있지만, 일반적으로 `synchroized` 는 시스템 성능에 악영향을 미친다.
    - 하지만 자바 8 스트림을 이용하면 기존의 자바 스레드 API보다 쉽게 병렬성을 활용할 수 있다.
        - 큰 스트림을 병렬로 처리할 수 있도록 작은 스트림으로 분할한다.
        - 그리고 filter와 같은 라이브러리 메서드로 전달된 메서드가 다른 코드와 상호작용 하지 않는다면 가변 공유 객체를 통해 병렬성을 누릴 수 있다.
        - 함수형에서 함수란?
            1. 일급값으로 사용한다. (주 의미)
            2. 프로그램이 실행되는 동안 컴포넌트 간 상호작용이 일어나지 않는다. (부가 의미)
- 자바 함수
    - 프로그래밍 언어에서 함수라는 용어는 메서드 특히 정적 메서드와 같은 의미로 사용된다.
    - 자바의 함수는 이에 더해 수학적인 함수처럼 사용되며 부작용을 일으키지 않는 함수를 의미한다.
    - **자바 8에서는 함수를 새로운 값의 형식으로 추가**했다. (멀티코어에서 병렬 프로그래밍을 활용할 수 있는 스트림과 연계될 수 있도록 함수를 만들었기 때문이다.)
- 자바 프로그램에서 조작할 수 있는 값의 종류
    1. Primitive Data Type
    2. Reference Data Type(객체의 참조: 클래스의 인스턴스를 의미)
    3. new 또는 Factory Method(디자인 패턴) 또는 라이브러리 함수를 이용해서 얻은 객체
    
- 프로그래밍 언어의 핵심 `“값 바꾸기”`
    - 기존
        - 일급 값(시민) - 기본형, 참조형 데이터 : ****************************************************전달할 수 있는 값****************************************************
        - 이급 값(시민) - 메서드, 클래스 등(구조체)  : **전달할 수 없는 구조체**
        - 자바 프로그래밍의 다양한 구조체(메서드, 클래스)가 값의 구조를 표현하는 데 도움이 될 수 있지만, 이러한 모든 구조체는 그 자체로는 값이 될 수 없다.
        - 그래서 구조체들은 자유롭게 전달할 수는 없다.
    - 자바 8
        - 런타임에 메서드를 값처럼 전달할 수 있다면, 프로그래밍에서 유용하게 활용할 수 있다.
        - 즉 이급 시민을 일급 시민으로 바꿀 수 있는 기능을 추가하였다.
        - 스칼라와 그루비 같은 언어에서 메서드를 일급값으로 사용하면 프로그래밍이 수월해진다는 사실을 이미 실험을 통해 확인했다.
        - 그리고 이러한 기능에 익숙해지면 오히려 일급 시민이 부족한 다른 언어의 사용을 기피하는 현상까지 발생한다.
        - 그래서 자바 8의 설계자들은 메서드와 람다를 일급 시민 값으로 취급할 수 있도록 결정하였다.
- 메서드 참조와 람다
    - 메서드 참조(Method Reference) - `클래스명::메서드명` 과 같은 형식으로 사용한다.
    - 람다 (익명 함수) - `(int x) → x + 1`과 같은 형식으로 사용한다.
        - 한 번만 사용할 메서드를 매 번 정의하고 사용하는 것 번거로우므로 간결한 람다를 지원한다.
    
    ⇒ 람다가 길어진다면 익명 람다보다는 코드가 수행하는 일을 잘 설명하는 이름을 가진 메서드를 정의하고 메서드 참조를 활용하는 것이 더 바람직하다.
    
- 스트림
    - ‘컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제’ & ‘멀티코어 활용 어려움’이라는 두 가지 문제를 모두 해결했다.
    
    1. 반복되는 패턴 (필터링, 추출, 그룹화, 포킹)을 라이브러리에서 제공
    2. 멀티코어 활용
        - 컬렉션 - 데이터를 어떻게 저장하고 접근할지 중점
        - 스트림 - 스트림 내의 요소를 쉽게 병렬로 처리할 수 있는 환경을 제공하는 것이 중점
    
    - 거의 모든 자바 애플리케이션을 컬렉션을 만들고 활용한다.
    - 하지만 컬렉션으로 모든 문제가 해결되지 않는다.
    - 컬렉션에서는 반복 과정을 직접 처리해야 했다.
    - 스트림 API를 이용하면 컬렉션 API와 상당히 다른 방식으로 데이터를 처리할 수 있다.
    - 컬렉션 - for-each 루프(외부 반복)를 통한 작업 수행하므로 많은 요소를 가진 목록을 반복한다면 오랜 시간이 걸릴 수 있다.
        - 단일 CPU로 거대한 데이터를 처리하기 힘들기 때문에 우리는 서로 다른 CPU 코어에 작업을 각각 할당해서 처리 시간을 줄일 수 있다면 좋을 것이다.(병렬 처리 필요)
    - 스트림 - 내부 반복으로 모든 데이터에 대한 작업 수행하므로 루프에 대한 신경 X
    - 자바 8 이전 자바 버전에서 제공하는 스레드 API로 멀티스레딩 구현하여 병령성을 이용하는 것은 쉽지 않다. (순차적인 모델보다 멀티스레딩 모델을 다루기가 더 어려움)
- 디폴트 메서드와 자바 모듈
    - 자바 8에서는 인터페이스 규격 명세에 default라는 새로운 키워드를 지원한다.
    - 인터페이스 업데이트 시 해당 인터페이스를 구현하는 모든 클래스에도 업데이트가 필요했다.
    - 그러므로 인터페이스에 대한 업데이트는 불가능에 가까웠다.
    - 그래서 등장한 게 “디폴트 메서드”이다.
    - 자바 8에서 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가할 수 있는 기능인 default method를 제공한다.
    - default method의 메서드 본문은 구현 클래스에서 구현하는 것이 아니라 인터페이스의 일부로 포함된다.
    - 그러므로, 디폴트 메서드를 이용하면 기존 코드를 건드리지 않고도 원래의 인터페이스 설계를 자유롭게 확장할 수 있다.
    - 여러 인터페이스 구현 시 default method가 중복된다면? `다이아몬드 상속 문제`
    - 구현하는 클래스에서 반드시 오버라이딩해야 한다. (안 그러면 컴파일 오류)
