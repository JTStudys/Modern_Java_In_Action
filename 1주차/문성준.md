# 1. 자바의 주요 변화

# 자바의 발전

### 자바 1.0

스레드와 lock, 메모리 모델까지 지원했다. (저수준 기능을 온전히 활용하기 어려웠다.)

### 자바 5

스레드 풀, 병렬 실행 컬렉션 등 강력한 도구 도입

### 자바 7

병렬 실행에 도움을 줄 수 있는 fork()/join() 프레임워크를 제공했지만 여전히 개발자가 활용하기는 쉽지 않았다.

### 자바 8

혁명 그자체. 이 때부터 확 변했다고 해도 과언이 아니다.

병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법을 제공한다.
→ 이러한 쉬운 접근 방법을 활용하려면 **규칙을 알아야만 한다**.
간결한 코드, 멀티코어 프로세서의 쉬운 활용이라는 두 가지 요구사항을 기반으로 한다.

- 스트림API
- 메서드에 코드를 전달하는 기법
- 인터페이스의 디폴트 메서드

스트림을 이용하면 에러를 자주 일으키며 멀티코어 cpu를 이용하는 것보다 비용이 훨씬 비싼 synchronized를 사용하지 않아도 된다.
또한, 스트림 덕분에 **메서드에 코드를 전달하는 간결한 기법** (메서드 참조와 람다), 인터페이스의 **디폴트 메서드**가 존재할 수 있음을 알 수 있다.

이게 왜 좋은것일까 ?

→ 메서드에 코드를 전달하는 기법을 이용한다면, 새롭고 간결한 방식으로 동작 파라미터화를 구현할 수 있기 때문이며, 자바 8 기법은 함수형 프로그래밍에서 위력을 발휘한다.

```java
inventory.sort(comparing(Apple::getWeight));
```

### 자바 9

리액티브 프로그래밍이라는 병렬 실행 기법을 지원한다.
해당 기법을 사용할 수 있는 상황은 한정되어 잇지만, 수요가 많은 고성능 병렬 시스템에서 특히 인기를 얻고 있는 Rxjava를 표준방식으로 지원한다.

### 각 언어의 장단점

c,c++ 의 경우 안전성은 부족하지만 작은 runtime footprint 덕분에 os 와 임베디드 시스템에서 각광받는다.
but lack of safety 때문에 어플리케이션(프로그램)이 예기치 않게 종료되거나 바이러스 등이 공격할 수 있는 보안 구멍이 있다. 
→ 이 안전성 부족은 런타임 풋프린트에 여유가 있는 app에서는 java, c# 같이 안전한 언어가 c,c++을 압도한다.

### 스트림 처리

스트림이란 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다. 
즉, 1:1 대응되는 데이터의 집합체다.
이 집합체를 각각으로 보게된다면 동시에 작업을 처리하지만, 집합체로 본다면 1개의 큰 작업을 수행하는 것이다.
(쉽게 설명하여, 집합체 - 자동차 공장, 조립 라인 : 각각의 작업)

스트림 API의 핵심
기존에는 한 번에 한 항목을 처리했지만 이제 자바 8에선 우리가 하려는 작업(DB 질의처럼) 고수준으로 추상화하여 일련의 스트림으로 만들어 처리가 가능하다.
또한 스트림 파이프라인을 이용하여 입력 부분을 여러 cpu 코어에 쉽게 할당할 수 있다. → 스레드라는 복잡한 작업을 사용하지 않으면서도 almost free로 병렬성을 얻을 수 있따.

### 동작 파라미터화

코드 일부를 API로 전달하는 기능이다.
다시 말해, 메서드를 다른 메서드의 인수로 넘겨주는 기능을 제공한다. (그림 1-2, 1-3 참고)
compareUsingCustomerId를 이용해 sort의 동작을 파라미터화 했던 것처럼 stream API는 연산의 동작을 파라미터화 할 수 있는 코드를 전달한다는 사상을 기초로 하기 때문이다. 
<1-1>

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/75c82d3d-afc5-4eab-9039-61c7d4203760/Untitled.jpeg)

<1-2>

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/9733da21-ac97-49db-947a-236e70392de7/Untitled.jpeg)

### Parallelism and shared mutable data

병렬성을 공짜로 얻을 수 있다로 시작된다.
세상에 공짜는 없다. → 병렬성을 얻기 위해 무언가를 포기해야한다.
→ 스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꿔야한다.
스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행 하더라도 안전하게 실행되어야 한다.
다른 코드와 동시에 실행 하더라도 **안전하게 실행할 수 있는 코드**를 만들려면 공유되어진 가변 데이터 에 접근하지 않아야한다. (이를 순수, 부작용 없는, 상태 없는 함수라고 한다)
다중 프로세싱 코어에서 synchronized를 사용하면 다중 처리 코어에선 코드가 순차적으로 실행되어야 하는데, 병렬이라는 취지로 이를 무력화 시키기 때문에 비싼 대가를 치러야 한다.

# 1.3 자바 함수

함수 : 메서드, 보통 정적메서드와 같은 의미로 사용된다.
자바의 함수는 이를 더해 수학적인 함수처럼 사용되며 부작용을 일으키지 않는 함수이다.

함수가 왜 필요할까?
프로그래밍 언어의 핵심은 값을 바꾸는 것이다. 프로그래밍 언어에선 이 값을 일급(firstClass) 값/시민 이라 한다.
프로그램을 실행하는 동안 다양한 구조체(메서드, 클래스 같은)를 자유롭게 전달할 수는 없다.
이렇게 전달할 수 없는 구조체를 이급 시민이라 한다.
위에 언급한 값은 모두 일급 자바 시민이지만 메서드, 클래스 등은 이급 자바 시민에 해당한다. 인스턴스화한 결과가 값으로 귀결되는 클래스를 정의할 때 메서드를 유용하게 활용할 수 있지만, 여전히 메서드와 클래스는 그 자체로 값이 될 수 없기 때문이다. 그렇다면 런타임에 메서드를 전달할 수 있다면, 유용할 것이다. 
즉, 이급 시민을 일급 시민으로 바꿀 수 있는 기능을 추가했다.

### 메서드 참조

```java
File[] hiddenFiles = new File(".").listFiles(new FileFilter(){
	public boolean accept(File file){
			return file.isHidden(); -> 숨겨진 파일 필터링
	}
});
		|	 
		|
		V
File[] hiddenFiles = new File(".").listFiles(File::isHidden); // 이렇게 바꿀 수 있음
```

**::** → 이 메서드를 값으로 사용하라는 의미, 일급이 됨
기존에 객체 참조(new로 객체 참조를 생성함)을 이용해서 객체를 이리저리 주고받았던 것처럼 자바 8에서는 File::isHidden을 이용해서 메서드 참조를 만들어 전달할 수 있게 되었다.

### 람다 : 익명 함수

자바8 에는 메서드를 일급 값으로 취급할 뿐 아니라 람다(또는 익명함수)를 포함하여 함수도 값으로 취급할 수 있다.
이말은 

```java
(int x) → x+1  // x라는 인수로 호출하면서 x+1을 반한
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/44eea2c9-5eaa-48bf-8584-7f016e5b3442/Untitled.jpeg)

### 필터/코드 넘겨주기

특정 항목을 선택해서 반환하는 동작을 말한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/1a155272-8fe9-4efe-b569-81d049661f89/Untitled.jpeg)

자바 8에선 코드를 인수로 넘겨줄 수 있으므로 위에처럼 filter 메서드를 중복으로 구현할 필요가 없다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/d164d8cd-086b-445b-974c-9726718bb308/Untitled.jpeg)

Predocate 란? 인수로 값을 받아 true || false를 반환하는 함수를 말한다.

### 메서드 전달에서 람다로

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/f0d013e7-ce00-46b0-b2a4-5a9ef37ad4d2/Untitled.jpeg)

# 1.4 스트림

거의 모든 자바 애플리케이션은 **컬렉션을 만들고 활용**한다.
But 컬렉션으로 모든 문제가 해결되는 것은 아니다. 예를 들어 리스트에서 고가의 트랜잭션만 필터링한 다음에 통화로 결과를 그룹해야 한다고 가정한다면, 다음 코드처럼 많은 기본 코드를 구현해야 한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/0b8a6716-0e5c-4b63-834c-ff77dde46979/Untitled.jpeg)

위 코드는 중첩된 제어 흐름 문장이 많아서 코드를 한 번에 이해하기 어렵다.
이를 **스트림 API를 이용**한다면 아래와 같이 해결할 수 있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/aa6e8f5b-10e6-432c-a852-7c4f0be8018f/Untitled.jpeg)

여기서 key point 는
스트림 API를 이용하면 컬렉션 API와는 상당히 다른 방식으로 데이터를 처리할 수 있다는 사실을 기억하자.
컬렉션에서는 반복과정을 직접 처리해야 했다. 즉 for-each 루프를 이용해서 각 요소를 반복하면서 작업을 수행했다. 이런 방식의 반복을 **외부반복**이라 한다.
반면 스트림 API를 이용하면 loop를 신경 쓸 필요가 없다. 스트림 API에서는 라이브러리 내부에서 모든 데이터가 처리된다. 이와 같은 반복을 **내부반복**이라고 한다.

### 멀티스레딩은 어렵다

자바에서 제공되는 스레드 API로 멀티스레딩 코드를 구현해서 병렬성을 이용하는 것은 쉽지 않다.
멀티스레딩 환경에서 각각의 스레드는 동시에 공유된 데이터에 접근 및 갱신할 수 있다. 
이는 스레드를 잘 제어하지 못한다면 원치 않는 방식으로 데이터가 바뀔 수 있다는 것을 의미한다.
아래와 같은 상황이 발생할 수 있음을 의미한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/08bb99de-37b2-4890-8edb-3d089fd75c3e/Untitled.jpeg)

자바 8의 스트림 API로 ‘컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제’와 
‘멀티코어 활용 어려움’이라는 두 가지 문제를 모두 해결했다.
즉, 자주 반복되는 패턴으로 주어진 조건에 따라 데이터를 **필터링**하거나(예를 들면 무게에 따라 사과 선택),
데이터를 **추출** 하거나(예, 리스트에서 각 사과의 무게 필드 추출), 데이터를 **그룹화**하는(예, 숫자 리스트의 숫자를 홀수와 짝수로 그룹화)등의 기능이 있다.
또한 이러한 동작들을 쉽게 **병렬화** 할 수있다는 점도 변화의 동기가 되었다.
아래와 같이 예를 들어보자.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/cd34cfbd-fd25-4f56-b033-f08ca05214c2/Untitled.jpeg)

(1) 두 CPU를 가진 환경에서 리스트를 필터링할 때 한 CPU는 리스트의 앞부분을 처리하고, 다른 CPU는 리스트의 뒷 부분을 처리하도록 요청할 수 있다. 이러한 과정을 **포킹 단계**라고 한다.

(2) 그후, 각각의 CPU는 자신이 맡은 절반의 리스트를 처리한다.

(3) 마지막으로 하나의 CPU가 두 결과를 정리한다.
참고로, 구글의 검색 엔진도 이와같은 방식으로 작동하면서 빠르게 검색 결과를 제공한다.

<aside>
💡 새로운 스트림 API도 기존의 컬렉션 API와 아주 비슷한 방식으로 동작한다고(즉, 두 방식 모두 순찾거인 데이터 항목 접근 방법을 제공한다고) 간주할 것이다.
다만 **컬렉션**은 어떻게 데이터를 저장하고 접근할지에 중점을 둔다.
**스트림**은 데이터에 어떤 계산을 할 것인지를 묘사하는 것에 중점을 둔다는 점을 기억하자.
스트림의 **핵심**은 스트림 내의 요소를 쉽게 병렬로 처리할 수 있는 환경을 제공한다는 것이다.

</aside>

→ 컬렉션을 필터링할 수 있는 가장 빠른 방법은 컬렉션을 스트림으로 바꾸고, 병렬로 처리한다음에, 리스트로 다시 복원하는 것이다. → 스트림과 람다 표현식을 이용하면 ‘병렬성을 공짜로’ 얻을 수 있으며, 리스트에서 사과를 순차적으로 또는 병렬로 필터링할 수 있기 때문이다.

이것은 순차 처리 방식의 코드다.

```java
import static java.util.Stream.Collectors.toList;
List<Apple> heavyApples =
	inventory.***stream()***.filer(Apple a) -> a.getWeight() > 150)
										.collect(toList());
```

이것은 병렬 처리 방식의 코드

```java
import static java.util.stream.Collectors.toList;
List<Apple> heavyApples =
	inventory.***parallelStream()***.filer(Apple a) -> a.getWeight() > 150)
										.collect(toList());
```

### 자바의 병렬성과 공유되지 않은 가변 상태

자바 8은 두 가지의 요술방망이를 제공한다.
우선 라이브러리에서 분할을 처리한다.
즉, 큰 스트림을 병렬로 처리할 수 있도록 작은 스트림으로 분할한다는 것이다.
또한 filter 같은 라이브러리 메서드로 전달된 메서드가 상화작용을 하지 않는다면 가변 공유 객체를 통해 공짜로 병렬성을 누릴 수 있다.
상호작용을 하지 않는다는 제약은 프로그래머 입장에선 상당히 자연스러운 일이다.(예를 들어 `Apple::isGreenApple`를 생각해보자)
함수형 프로그래밍에서 함수형이란 ‘**함수를 일급값으로 사용한다**’라는 의미도 있지만 부가적으로 ‘**프로그램이 실행되는 동안 컴포넌트 간에 상호 작용이 일어나지 않는다**’라는 의미도 포함되어있다.

### 디폴트 메서드

자바의 변화 과정에서 자바8 개발자들이 겪는 어려움 중 하나는 기존 인터페이스의 변경이다. 예를 들어 `Collections.sort`는 사실 List 인터페이스에 포함되지만 실제로 List로 포함된 적은 없다. 이론적으로는 `Collection.list(list, comparator)`가 아니라 `list.sort(comparator)`를 수행하는 것이 적절하다. 사소한 문제처럼 보일 수 있지만, 자바 8이 등장하기 전까지는 이 문제 해결이 불가능 했다.
BUT, java 8에선 **디폴트 메서드**로 해결했다.

# 1.5 디폴트 메서드와 자바 모듈

이전에 설명한 것처럼 요즘은 외부에서 만들어진 컴포넌트를 이용해 시스템을 구축하는 경향이 있다.
이와 관련해 지금까지 자바에서는 특별한 구조가 아닌 평범한 자바 패키지 집합을 포함하는 JAR 파일을 제공하는 것이 전부였다.
but, 자바 9의 모듈 시스템은 모듈을 정의하는 문법을 제공한다.
이를 통해 패키지 모음을 포함하는 **모듈을 정의**할 수 있다.
모듈 덕분에 JAR 같은 컴포넌트에구조를 적용할 수 있으며 문서화와 모듈 확인 작업이 용이해졌다.
또한, 자바 8에선 **인터페이스를 쉽게 바꿀 수 있도록 디폴트 메서드를 지원**한다.

결정적으로 자바 8은 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가할 수 있는 기능을 제공한다. 메서드 본문은 클래스 구현이 아니라 인터페이스의 일부로 포함된다(그래서 이를 디폴트 메서드라고 부른다).

디폴트 메서드를 이용하면 기존의 코드를 건드리지 않고도 원래의 인터페이스 설계를 자유롭게 확장할 수 있다는 장점이 잇다. 예를 들어 List에 직접 sort 메서드를 호출할 수 있다. 이는 자바 8의 List 인터페이스에 당므과 같은 디폴트 메서드 정의가 추가되었기 때문이다(이 디폴트 메서드는 정적메서드인 Collections.sort를 호출한다).

```java
default void sort(Comparator<? super E> c){
	Collection.sort(this, c);
}
```

따라서 자바 8부터는 디폴트 sort를 구현하지 않아도 된다.

### 다이아몬드 상속문제란 ?

n개의 인터페이스를 **상속** 받았을 때, n개의 인터페이스에 동일한 메서드 시그니처를 가지는 메서드를 default method로 구현하고 있다면 자바의 다중**상속 문제**와 같이 어떠한 method가 호출될 지 결정할 수 없고 충돌하는 **문제**를 의미한다. (****인터페이스의 default method와 다이아몬드 문제가 키포인트)****
